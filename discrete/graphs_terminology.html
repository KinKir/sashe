<!DOCTYPE html>
<html lang="en">

<head>
    <!-- Required meta tags -->
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
    <meta name="description" content="Learning Discrete Mathematics" />
    <meta name="author" content="Ilija Taseski" />

    <title>io sashe</title>

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"
        integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

    <!-- Documentation extras -->
    <link href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" rel="stylesheet">
    <link href="../css/docs.css" rel="stylesheet" />

    <!-- MathJax -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async>
    </script>

    <!-- Favicons -->
    <link rel="apple-touch-icon" href="../images/favicons/apple-touch-icon.png" sizes="180x180">
    <link rel="icon" href="../images/favicons/favicon-32x32.png" sizes="32x32" type="image/png" />
    <link rel="icon" href="../images/favicons/favicon-16x16.png" sizes="16x16" type="image/png" />
    <link rel="manifest" href="../images/favicons/manifest.json" />
    <link rel="mask-icon" href="../images/favicons/safari-pinned-tab.svg" color="#563d7c" />
    <link rel="icon" href="../images/icon/favicon.ico" />
    <meta name="msapplication-config" content="../images/favicons/browserconfig.xml" />
    <meta name="theme-color" content="#563d7c" />

    <!-- Font Awesome JS -->
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css"
        integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous" />
</head>

<body>
    <!-- Header -->
    <a id="skippy" class="sr-only sr-only-focusable" href="#content">
        <div class="container">
            <span class="skiplink-text">Skip to main content</span>
        </div>
    </a>

    <header class="navbar navbar-expand navbar-dark flex-column flex-md-row bd-navbar">
        <a class="navbar-brand mr-0 mr-md-2" href="../index.html" aria-label="Bootstrap">
            <svg class="d-block" width="36" height="36" viewbox="0 0 612 612" xmlns="http://www.w3.org/2000/svg"
                focusable="false">
                <title>Саше учи Calculus</title>
                <path fill="currentColor"
                    d="M510 8a94.3 94.3 0 0 1 94 94v408a94.3 94.3 0 0 1-94 94H102a94.3 94.3 0 0 1-94-94V102a94.3 94.3 0 0 1 94-94h408m0-8H102C45.9 0 0 45.9 0 102v408c0 56.1 45.9 102 102 102h408c56.1 0 102-45.9 102-102V102C612 45.9 566.1 0 510 0z" />
                <path fill="currentColor"
                    d="M196.77 471.5V154.43h124.15c54.27 0 91 31.64 91 79.1 0 33-24.17 63.72-54.71 69.21v1.76c43.07 5.49 70.75 35.82 70.75 78 0 55.81-40 89-107.45 89zm39.55-180.4h63.28c46.8 0 72.29-18.68 72.29-53 0-31.42-21.53-48.78-60-48.78h-75.57zm78.22 145.46c47.68 0 72.73-19.34 72.73-56s-25.93-55.37-76.46-55.37h-74.49v111.4z" />
            </svg>
        </a>

        <div class="navbar-nav-scroll">
            <ul class="navbar-nav bd-navbar-nav flex-row">
                <li class="nav-item">
                    <a class="nav-link active" href="propositional_logic.html">Дискретна математика</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="../discrete_exercises/propositional_logic_university.html">
                        <span>
                            <i class="fas fa-chalkboard-teacher"></i>
                        </span>
                        Вежби
                    </a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="../discrete_exercises/graph.html">
                        <span>
                            <i class="fas fa-book"></i>
                        </span>
                        Вежби
                    </a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="../discrete_colloquium/propositional_logic_colloquium.html">
                        <span>
                            <i class="fas fa-graduation-cap"></i>
                        </span>
                        Колокфиум
                    </a>
                </li>
            </ul>
        </div>
    </header>

    <!--Container -->
    <div class="container-fluid">
        <div class="row flex-xl-nowrap">
            <div class="col-12 col-md-3 col-xl-2 bd-sidebar">
                <form class="bd-search d-flex align-items-center">
                    <input type="search" class="form-control" id="search-input" placeholder="Search in discrete math..."
                        aria-label="Search for..." autocomplete="off" data-siteurl="https://getbootstrap.com"
                        data-docs-version="4.1" />
                    <button class="btn btn-link bd-search-docs-toggle d-md-none p-0 ml-3" type="button"
                        data-toggle="collapse" data-target="#bd-docs-nav" aria-controls="bd-docs-nav"
                        aria-expanded="false" aria-label="Toggle docs navigation">
                        <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 30 30" width="30" height="30"
                            focusable="false">
                            <title>Menu</title>
                            <path stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-miterlimit="10"
                                d="M4 7h22M4 15h22M4 23h22" />
                        </svg>
                    </button>
                </form>

                <!-- Left Sidenav -->
                <nav class="collapse bd-links" id="bd-docs-nav">
                    <div class="bd-toc-item">
                        <a class="bd-toc-link" href="propositional_logic.html">
                            1. Логика и докази
                        </a>

                        <ul class="nav bd-sidenav">
                            <li>
                                <a href="propositional_logic.html">
                                    Исказна логика
                                </a>
                            </li>
                            <li>
                                <a href="propositional_logic-app.html">
                                    Примена на исказна логика
                                </a>
                            </li>
                            <li>
                                <a href="propositional_logic_equivalences.html">
                                    Исказни еквиваленции
                                </a>
                            </li>
                            <li class="active bd-sidenav-active">
                                <a href="predicates.html">
                                    Предикати и квантификатори
                                </a>
                            </li>
                            <li>
                                <a href="predicates_nested.html">
                                    Вгнездени квантификатори
                                </a>
                            </li>
                            <li>
                                <a href="predicates_inference.html">
                                    Правила за изведување на заклучоци
                                </a>
                            </li>
                            <li>
                                <a href="proof.html">
                                    Докази
                                </a>
                            </li>
                        </ul>
                    </div>

                    <div class="bd-toc-item">
                        <a class="bd-toc-link" href="sets.html">
                            2. Основни структури
                        </a>

                        <ul class="nav bd-sidenav">
                            <li class="active bd-sidenav-active">
                                <a href="sets.html">
                                    2.1 Множества
                                </a>
                            </li>
                            <li>
                                <a href="sets_operations.html">
                                    2.2 Операции над множества
                                </a>
                            </li>
                            <li>
                                <a href="">
                                    2.3 Функции
                                </a>
                            </li>
                        </ul>
                    </div>

                    <div class="bd-toc-item active">
                        <a class="bd-toc-link" href="graphs.html">
                            10. Графови
                        </a>

                        <ul class="nav bd-sidenav">
                            <li>
                                <a href="graphs.html">
                                    10.1 Граф
                                </a>
                            </li>
                            <li class="active bd-sidenav-active">
                                <a href="graphs_terminology.html">
                                    10.2 Терминологија и специјални типови на графови
                                </a>
                            </li>
                            <li>
                                <a href="graphs_representing.html">
                                    10.3 Претставување на граф
                                </a>
                            </li>
                            <li>
                                <a href="graphs_connecting.html">
                                    10.4 Поврзување
                                </a>
                            </li>
                            <li>
                                <a href="graphs_euler.html">
                                    10.5 Оилеров пат
                                </a>
                            </li>
                            <li>
                                <a href="graphs_shortest_path_problem.html">
                                    10.6 Проблем на најкраток пат
                                </a>
                            </li>
                        </ul>
                    </div>

                    <div class="bd-toc-item">
                        <a class="bd-toc-link" href="sets.html">
                            11. Дрва
                        </a>

                        <ul class="nav bd-sidenav">
                            <li class="active bd-sidenav-active">
                                <a href="sets.html">
                                    2.1 Множества
                                </a>
                            </li>
                            <li>
                                <a href="sets_operations.html">
                                    2.2 Операции над множества
                                </a>
                            </li>
                            <li>
                                <a href="">
                                    2.3 Функции
                                </a>
                            </li>
                        </ul>
                    </div>
                </nav>
            </div>

            <!-- right nav -->
            <div class="d-none d-xl-block col-xl-2 bd-toc">
                <ul class="section-nav">
                    <li class="toc-entry toc-h2">
                        <a href="#terminology">Терминологија</a>
                    </li>
                    <li class="toc-entry toc-h3">
                        <a href="#models">Некои специјални едноставни графови</a>
                    </li>
                </ul>
            </div>

            <!-- main -->
            <main class="col-12 col-md-9 col-xl-8 py-md-3 pl-md-5 bd-content" role="main">
                <div class="row">
                    <div class="col-md-12">
                        <p class="lead">
                            Овде ќе се воведе базичен терминолошки речник на теоријата на графовите. Речникот ќе се
                            користи при решавање на многу различни
                            видови проблеми. Исто така, ќе се претстават неколку важни семејства на графови кои често се
                            користат како примери и во
                            моделите. Ќе бидат опишани неколку важни апликации каде ќе се појават овие специјални типови
                            на графикони.
                        </p>

                        <h3 id='terminology'>Основна терминологија</h3>

                        <p>
                            Прво ќе ја дадеме терминологијата која ги опишува јазлите и ребрата кај неориентираниот
                            граф.
                        </p>


                        <div id="term_01" class="alert alert-success swatch-purple" role="alert">
                            <h4 class="alert-heading">Дефиниција 1</h4>
                            <p>
                                Две темиња `u` и `v` во неориентиран граф `G` се нарекуваат соседни во `G` ако `u` и `v`
                                се крајни точки на некое ребро во `G`.
                            </p>
                        </div>

                        <p>
                            Ако `e={u,v}`, се вели дека `е` ги <strong>поврзува</strong> `u` и `v` или е
                            <strong>инцидентно</strong> со `u` и `v`
                        </p>

                        <p>
                            Исто така од корист е и терминологијата која го опишува множеството на јазли кое е соседно
                            на одреден јазол од графот.
                        </p>

                        <div id="term_02" class="alert alert-success swatch-purple" role="alert">
                            <h4 class="alert-heading">Дефиниција 2</h4>
                            <p>
                                Множеството од сите соседи на јазолот `v` од `G = (V, E)`, се означува со `N(v)`, и се
                                вика соседство на на `v`. Ако `A` е подмножество од `V` , со N(A) го означуваме
                                множеството во `G` кое е сосед на најмалку еден јазол во `A`. Од тука `N(A) = uuu_(v in
                                A) N(v)`.
                            </p>
                        </div>

                        <p>
                            За да може да се одреди колку ребра се врзани на јазелот, се користи следната дефиниција.
                        </p>

                        <div id="term_03" class="alert alert-success swatch-purple" role="alert">
                            <h4 class="alert-heading">Дефиниција 3</h4>
                            <p>
                                Степен на едно теме во неориентиран граф е бројот на ребра кои поврзани со него, освен
                                што алка се брои два пати, Степенот на јазелот се означува со `deg(v)`.
                            </p>
                        </div>

                        <p>
                            <strong>Пример 1. </strong> Кој е степенот кои се соседните јазли на јазлите во графот `G` и
                            `H` прикажани на сликата 1?
                        </p>

                        <img src="images/graph_15.PNG" class="img-fluid" alt="graph_15" />

                        <p>
                            <strong>Решение: </strong> <br>
                            граф `G`<br>
                            `deg(a) = 2`, `deg(b) = deg(c) = deg(f) = 4`, `deg(d) = 1`, `deg(e) = 3`, и `deg(g) = 0`.
                            <br>
                            Соседи на јазлите се: `N(a) = {b, f}`, `N(b) = {a, c, e, f}`, `N(c) = {b, d, e, f}`, `N(d) =
                            {c}`, `N(e) = {b, c, f }`, `N(f ) = {a, b, c, e}`, и `N(g) = ∅`. <br>
                            граф `H`<br>
                            `deg(a) = 4`, `deg(b) = deg(e) = 6`, `deg(c) = 1`, и `deg(d ) = 5`<br>
                            Соседи на јaзлите се: `N(a) = {b, d, e}`, `N(b) = {a, b, c, d, e}`, `N(c) = {b}`, `N(d) =
                            {a, b, e}`, и `N(e) = {a, b, d}`.
                        </p>

                        <p>
                            Јазол се степен нула се вика изолиран јазол. Изолираниот јазол не е соседен со ниту еден
                            јазол.
                        </p>
                        <hr />

                        <p>
                            <strong>Пример 2. </strong> Кој е степенот на јазелот во графот а преклопување во
                            екологијата ? Кои јазли во овој граф се соседи а кои се приврзоци?
                        </p>

                        <img src='images/graph_11.PNG' class='img-fluid' alt='graph_11'>

                        <p>
                            <strong>Решение: </strong> <br>
                            `deg(Rac`co`on) = 3`, `deg(Hawk) = 3`, deg(Owl) = 3`, deg(Oposs`u`m) = 3`, `deg(Squirrel) =
                            4`, `deg(Crow) = 3`, `deg(Shrew)= 3`, `deg(Mouse) = 1` и `deg(Wo`o`dpecker) = 3`<br>
                            Соседи на јазлите се: `Raccoon, Haw, Owl, Opossum, Squirrel, Crow, Shrew, Woodpecker<br>
                            Привезок е Mouse бидејки има само степен = 1.

                        </p>

                        <p>
                            Што се добива кога ќе се соберат сите степени од сите јазли од графот `G = (V, E)`? Секое
                            ребро додава два на сумата од степенот бидејки реброто поврзува два јазли. Ова значи дека
                            сумата од степените на јазлите е двапати поголема од бројот на ребрата. Ова е искажано со
                            теоремата 1 која се нарекува теорема на ракување (и е исто така позната као лема на
                            ракување).
                        </p>

                        <div id="term_04" class="alert alert-success swatch-purple" role="alert">
                            <h4 class="alert-heading">Теорема на ракување</h4>
                            <p>
                                Нека `G = (V, E)` е неориентиран граф со `m` јазли. Тогаш:<br>
                                `2m = sum_(v in V) deg(v)`.<br>
                                <em>Забелешка: Ова важи и кога графот има повеќекратни ребра и алки</em>
                            </p>
                        </div>

                        <p>
                            <strong>Пример 3. </strong>. Колку ребра има граф со 10 јазли, секој со степен 6.
                        </p>

                        <p>
                            <strong>Решение: </strong> <br>
                            Бидејки сумата на степените на јазлите е `6 * 10 = 60`, следи дека `2m = 60` каде `m` е
                            бројот на ребра. Од тука `m = 30`.
                        </p>

                        <p>
                            Теоремата 1 покажува дека сумата на степените на неоирентиран граф е парен број. Овој
                            едноставен факт има значајни последици, една од нив е дадена во теоремата 2.
                        </p>

                        <div id="term_05" class="alert alert-success swatch-purple" role="alert">
                            <h4 class="alert-heading">Теорема 2</h4>
                            <p>
                                Неориентиран граф има парен број на јазли кои се со непарен степен.
                            </p>
                        </div>

                        <p>
                            <strong>Доказ</strong> Нека `V1` и `V2` сe множество на јазли со парен степен и множество на
                            јазли со непарен степен.
                        </p>

                        <p>
                            `2m = sum_(v in V) deg(v) = sum_(v in V_1) deg(v) + sum_(v in V_2) deg(v)`
                        </p>

                        <p>
                            Бидејки `deg(v)` е парен број за `v in V1`, првиот член на десната страна од равенството е
                            парен број. Уште повеќе сумата на двата члена од десната страна на равенството е парен број
                            бидејки е `2m`. Од тука и вториот член на десната страна од равенството е парен број.
                            Бидејки сите членови во оваа сума се непарни броеви тогаш бројот на овие членови мора да e
                            парен број.
                        </p>

                        <p>
                            Терминологијата за графови со ориентирани ребра го одразува фактот дека ребрата воориентиран
                            факт имаат смер.
                        </p>

                        <div id="term_05" class="alert alert-success swatch-purple" role="alert">
                            <h4 class="alert-heading">Дефиниција 4</h4>
                            <p>
                                Кога `(u, v)` е ребро на графот `G` се вели дека `u` е сосед на `v` а `v` е сосед од
                                `u`. Јазелот `u` се нарекува <em>иницијален јазел</em> а `v` се нарекува <em>краен
                                    јазол</em>.
                            </p>
                        </div>

                        <p>
                            Бидејки ребрата во граф со ориентирани ребра се подредени парови, дефиницијата за степен на
                            јазол може да се усогласи за да го претстави бројот на ребра со овој јазол како иницијален
                            јазол и како краен јазол.
                        </p>

                        <div id="term_05" class="alert alert-success swatch-purple" role="alert">
                            <h4 class="alert-heading">Дефиниција 5</h4>
                            <p>
                                Во ориентиран граф, влезен степен на јазол `v`, означен како `deg ^(-) (v)`, е
                                бројот на ребра со `v` како нивни краен јазол. Излезен степен, означен како `deg
                                ^(+)(v)`, е
                                бројот
                                на ребра со `v` како нивен иницијален јазол.<br>
                                <em>Забелешка: Алка додава еден и кај влезниот и излезниот степен на јазолот.</em>
                            </p>
                        </div>

                        <p>
                            <strong>Пример 4. </strong> Да се одреди влезниот степен и излезниот степен на секој јазол
                            на графот `G` со ориентирани ребра даден на сликата 2.
                        </p>

                        <img src='images/graph_16.PNG' class='img-fluid' alt='graph_16'>

                        <p>
                            <strong>Решение: </strong> <br>
                            Влезни степени:<br>
                            `deg ^(-)(a) = 2`, `deg ^(-)(b) = 2`, deg ^(-)(c) = 3`, deg (-)(d) = 2`, `deg (-)(e) = 3` и
                            `deg(-)(f) = 0`<br>
                            `deg ^(+)(a) = 4`, `deg ^(+)(b) = 1`, deg ^(+)(c) = 2`, deg (+)(d) = 2`, `deg (+)(e) = 3` и
                            `deg(+)(f) = 0`<br>

                        </p>

                        <p>
                            Бидејки секое ребро има влезен јазол и излезен јазол, сумата на излезните степени и сумата
                            на влезните степени на сите јазли во графот е иста. И двете суми се бројот на ребра
                            во графот. Овој резултат е искажан во теоремата 3.
                        </p>

                        <div id="term_05" class="alert alert-success swatch-purple" role="alert">
                            <h4 class="alert-heading">Теорема 3</h4>
                            <p>
                                Нека `G = (V, E)` е граф со ориентирани ребра. Тогаш:<br>
                                `sum_(v in V) deg ^(-)(v) = sum_(v in V) deg ^(-) (v) = abs(E)`
                            </p>
                        </div>

                        <p>
                            Има многу особини на ориентираниот граф кои не се во зависност од на ориентираноста на
                            неговите ребра. Како последивца на ова, често е корисно да се игнорираат овие
                            ориентираности. Неориентираниот граф кој е резултат на игнорирање на ориентираноста на
                            ребрата се нарекува <strong>изведен неориентиран граф</strong>. Ориентираниот граф и
                            изведениот неориентиран граф имаат ист број на ребра.
                        </p>
                        <hr>

                        <h3 id='Some Special Simple Graphs'>
                            Некои специјални едноставни графови
                        </h3>

                        <p>
                            Ќе претставиме неколку класи на едноставни графови. Овие графови често се користат как
                            опримери или се јавуваат во многу апликации.
                        </p>

                        <p>
                            <strong>Комплетен граф </strong> Комплетен граф од `n` јазли, означен како `K_n`, е
                            едноставен граф кој има точно едно ребро помеѓу секој пар од различни јазли. Графовите за
                            `K_n`, за `n = 1, 2, 3, 4, 5, 6` , се прикажани на сликата 3. Едноставен граф каде постои
                            најмалку еден пар на различни јазли неповрзани со ребро се вика <strong>некомплетег
                                граф</strong>.
                        </p>

                        <img src='images/graph_17.PNG' class='img-fluid' alt='graph_17'>

                        <p>
                            <strong>Циклус граф </strong> означен како `c_n`, каде `n>=3` се состои од јазлите `v_1,
                            v_2,
                            . . . , v_n` и ребрата `{v_1, v_2}`, `{v_2, v_3}`, . . . , `{v_(n−1), v_n}`, и `{v_n, v_1}`.
                            Циклисот `C_3`,`C_4`,
                            `C_5`, и `C_6` е претставен на слика 4.
                        </p>

                        <img src='images/graph_18.PNG' class='img-fluid' alt='graph_18'>

                        <p>
                            <strong>Тркало граф </strong> се означува како `W_n` и се добива кога на циклус графот му се
                            додава дополнителен јазол и истиот се повре со сите јазли во циклус графот. Тркало граф
                            `W_3`, W_4`, `W_5` и `W_6` е прикажано на слика 5.
                        </p>

                        <img src='images/graph_19.PNG' class='img-fluid' alt='graph_19'>

                        <p>
                            <strong>`n` Коцка </strong> означена со `Q_n`, е граф кој има јазли кои претставуваат `2^n`
                            низа со должина `n`. Два јазли се соседни ако и само ако бројните низи кои ги претставуваат
                            се разликуваат во еден бит.
                        </p>

                        <img src='images/graph_20.PNG' class='img-fluid' alt='graph_20'>

                        <hr>

                        <h3 id=''>
                            Бипартитен (дводелен) граф
                        </h3>

                        <p>
                            Понекогаш графот има особина дека множеството на јазли може да се подели во две неповрзани
                            подмножества така да секое ребро поврзува јазол во едно од овие подмножества со јазол во
                            другото подмножество. На пример, да го земеме во предвид графот кој ги претставува браковите
                            во едно село, каде секоја личност е претставена со јазол во подмножеството на јазли кое ги
                            претставуваат мажите и јазол во подмножеството на јазли кое ги претставува жените. Ова води
                            до дефиницијата 5.
                        </p>

                        <div id="term_05" class="alert alert-success swatch-purple" role="alert">
                            <h4 class="alert-heading">Дефиниција 5</h4>
                            <p>
                                Едноставен граф `G` се нарекува дводелен ако неговото множество од јазли `V` може да се
                                подели во две неповрзани подмножества `V1` и `V2` така да секое ребро поврзува јазол од
                                `V_1` и јазол `V_2` (така да нема ребро во `G` кое поврзува два јазли во `V_1` или два
                                јазли во `V_2`). Кога овие услови се исполнети, тогаш парот `(V_1, V_2)` е
                                <strong>бибартиција</strong> на множеството јазли.
                            </p>
                        </div>

                        <p>
                            Во примерот 9 ќе се покаже дека `C_6` е дводелен граф а во примерот 10 дека `K3` не е
                            дведелен граф.
                        </p>

                        <p>
                            <strong>Пример 9. </strong> Графот `C_6` e дводелен граф бидејки неговото множество на јазли
                            може да се подели на две множества `V_1 = {v_1, v_3, v_5}` и `V_2 = {v_2, v_4, v_6}`, и
                            секое ребро од `C_6` поврзува јазол во `V_1` и јазол во `V_2`.
                        </p>

                        <img src='images/graph_21.PNG' class='img-fluid' alt='graph_21'>

                        <p>
                            <strong>Пример 10. </strong> `K_3` не е дводелен граф. Ако пробаме да го поделиме
                            множеството на јазли во две неповрзани множества едното мора да има два јазли. Ако графот е
                            дводелен овие два јазли не можат да бидат поврзани со ребро. Но кај `K_3_` секој јазол е
                            поврзан со секој друг јазол со ребро.
                        </p>

                        <p>
                            <strong>Пример 11. </strong> Дали грфовите `G` и `H` претставени на слика 8 се дводелни?
                        </p>

                        <img src='images/graph_22.PNG' class='img-fluid' alt='graph_22'>

                        <p>
                            <strong>Решение: </strong> Графот `G` е дводелен бидејки неговото множество на јазли е унија
                            на две раздвоени множества `{a, b, d}` и `{c, e, f, g}`, и секое ребро поврзува јазел од
                            едно од овие множества со јазол во другото множество. (Треба да се забележи дека за да `G`
                            биде дводелен графне е потребно да секој јазол `{a, b, d}` биде сосед на секој јазол во `{c,
                            e, f, g}`. На пример `b` и `g` не се соседи.)<br>
                            Графот `H` не е дводелен бидејки неговото множество не може да се подели на две подмножества
                            така да ребрата не поврзуваат два јазли од исто множество. (Види јазол `a`, `b`, и `f`.)
                        </p>

                        <p>
                            Теоремата 4 дава критериум за одредување кога еден граф е дводелен.
                        </p>

                        <div id="term_06" class="alert alert-success swatch-purple" role="alert">
                            <h4 class="alert-heading">Теорема 4</h4>
                            <p>
                                Едноставен граф е дводелен ако и само ако е можно да се додели eдна од две различни бои
                                на секој јазол од графот така да два соседни јазли немаат иста боја.
                            </p>
                        </div>

                        <p>
                            <strong>Доказ: </strong>Да претпоставиме дека `G = (V, E)` е дводелен едноставен граф. Тогаш
                            `V = V_1 uu V_2`, каде `V_1` и `V_2` се неповезани множества и секое ребро во `E` поврзува
                            јазол
                            во `V_1` и јазол во `V_2`. Ако се додели една боја на секој јазол во `V_1` и друга боја на
                            секој јазол во `V_2`, тогаш нема два соседни јазли кои имаат иста боја.
                        </p>

                        <p>
                            Сега да претпоставиме дека е можно да се додеалат две бои на јазлите на графот така да нема
                            два соседни јазли кои имаат иста боја. Нека `V_1` е множеството на јазли на кое му е
                            доделена првата боја а `V_2` е множеството на јазли на кое му е доделена другата боја. Тогаш
                            `V_1` и `V_2` се неповрзани и `V = V1 uu V2`. И уште повеќе, секое ребро кое поврзува јазол
                            во `V_1` и јазол во `V_2` бидејки нема два соседни јазли кои се или во `V_1` или во `V_2`.
                            Според ова, `G` е дводелен граф.
                        </p>

                        <p>
                            Ќе покажеме како теоремета 4 може да се употреби за да се одреди дали одереден граф е
                            дводелен или не.
                        </p>

                        <p>
                            <strong>Пример 12. </strong> Со употреба на теорема 4 да се одреди дали графот од примерот
                            11 е дводелен.
                        </p>

                        <p>
                            <strong>Решение: </strong> Прво ќе го разгледаме графот `G`.Ќе се обидеме да доделиме една
                            од двете бои, да речеме црвена и сина, на секој јазол во `G` така да ниедно ребро не
                            поврзува црвен јазол и син јазол. Ќе отпочнеме со произволно доделување на бои прво црвена
                            на a. Тогаш на мора на јазлите c, e, f и g да им се додели сина боја бидејки се соседни
                            ијазли со јазелот а. За да се избегне ребро со два јазли со сина боја, мора да се додели
                            црвена боја на сите јазли соседи на c, e, f и g. Ова значи дека мора да се додели црвена
                            боја b и d. Сега на сите јазли им е доделена боја. Црвени јазли се a, и b d а сини јазли се
                            c, e, f и g. Вака добиме да секое ребро поврзува црвен јазол со син јазол. Според теоремата
                            4 графот е дводелен.
                        </p>

                        <p>
                            Сега ќе се обидеме да доделиме или црвена или плава боја на секој јазол во графот `H` така
                            да нема ребро кое поврзува црвен јазол со син јазол. Прво нека доделиме црвена боја на
                            јазолот а. Потоа мораме да доделиме сина на јазлите b, e и f како соседи на a. Но ова не е
                            можно бидејки е и f се соседни јазли така да двата не можат да имаат иста боја. Според
                            теорем 4 графот не е дводелен
                        </p>

                        <p>
                            Теоремата 4 во делот на теорија на графовои е позната како боење на граф.
                        </p>

                        <p>
                            <strong>Пример 13. </strong> Комплетен дводелен граф `K_(m,n)` е граф кој има множество на
                            јазли поделено во во две подмножества `m` и `n`, и ребра помеѓу два јазли ако и само ако
                            еден јазол е во првото подмножество а другиот јазол е во второто подмножество. Комплетен
                            дводелен граф `K_(2,3)`, `K_(3,3)`, `K_(3,5)`, и `K_(2,6)` се прикажани на слика 9.
                        </p>

                        <img src='images/graph_23.PNG' class='img-fluid' alt='graph_23'>

                        <hr>

                        <h3 id=''>
                            Дводелен граф и совпаѓање
                        </h3>

                        <p>
                            Дводелен граф може да се употреби за да се моделираат многу типови на апликации кои
                            вклучуваат совпаѓање на елементи од едно множество со друго, како во примерот 14.
                        </p>

                        <p>
                            <strong>Пример 14. Работни задачи: </strong>Да претпоставиме дека имаме `m` запослени во
                            групата `a` и `n` различни работни задачиe кои треба да се извршат и каде `m ≥ n`. Секој
                            запослен е обучен за една или повеќе работни задачи од `n`. Сакаме да доделиме запослен на
                            секоја работна задача. За да ја ивршиме оваа задача можеме да искористиме граф за да
                            изградиме модел на способности на запослените. Секој запослен ќе го претставиме со јазол и
                            секоја работна задача со јазол. За секој запослен ќе вклучиме ребро од запослениот кон
                            секоја работна задача за која запослениот е обучен. Множеството на јазли на овој граф може
                            да се раздели во два неповрзани множества., множество на запослени и множество на работни
                            задачи каде секое ребро поврзува запослен со работна задача. Како последица на ова добиваме
                            дводелен граф каде бипартицијата е `(E, J)` и каде `E` е множеството на запослени а `J` е
                            мнеството на работни задачи. Сега имаме две можни сценарија.
                        </p>

                        <p>
                            Прво да претпоставиме дека групата на запослени е од четри члена. Alvarez, Berkowitz, Chen,
                            и Davis; и да претпоставиме дека имааме четри работни задачи за да го комплетираме проектот
                            1: барање, архитектура, имплементација и тестирање. requirements, architecture,
                            implementation, and testing. Да претпоставиме дека Alvarez е обучен за барања и тестирање;
                            Berkowitz е обучен за архитектура, имплементација и тестирање; Chen е обучен за барања,
                            архитектура и имплементација и Davis е обучен само за барања. Моделот за способности го
                            градиме употребувајки дводелен граф прикажан на сликата 10(a).
                        </p>

                        <p>
                            Второ, да претпоставиме дека имамае втора група на запослени од четри члена: Washington,
                            Xuan, Ybarra, and Ziegler; и да претпоставиме дека истите работни задачи треба да се извршат
                            за да се заврши проектот 2. Да препоставиме дека Washington е обучен за архитектура, Xuan е
                            обучен за барања, имплементација и тестирање, Ybarra е обучен за архитектура и Ziegler е
                            обучен за барања, архитектура и тестирање. Моделот за способностите е прикажан на сликата
                            10(b).
                        </p>

                        <p>.
                            За да се заврши работата во проектот 1, мора да доделиме запослен на секоја работна
                            задачатака да секоја работна задача има запослен доделен на неа и така да нема запослен кој
                            има две работни задачи. Ова може да се оствари со давање на тестирањето на Alvarez,
                            имплементацијата на Berkowitz, архитектурата на Chen и барањата на Davis како што е
                            прикажана на сликата 10(a) (каде плавите линии ја прикажуваат оваа распределба).
                        </p>

                        <p>
                            За проектот 2 мораме на секоја работна задача да му доделиме запослен така да секоја работна
                            задача има доделено запослен и секој запослен да нема повеќе од една работна задача. Но ова
                            не е можно бидејки имаме само двајца запослени Xuan и Ziegler кои кои се обучени за најмалку
                            една од трите работни задачи. Следствено не постои начин да доделиме троја различни
                            запослени на три различни задачи така да секоја работна задача се додели на запослен со
                            соодветна обука.
                        </p>

                        <img src='images/graph_24.PNG' class='img-fluid' alt='graph_24'>

                        <p class='text-danger'>
                            ---------- ОД ОВДЕ ПА НАТАКА СО ЦРВЕНО ГО НЕМА ВО ПРЕЗЕНТАЦИАЈАТА (НЕ Е ПРЕДАВАНО) ----------
                        </p>

                        <p class='text-danger'>
                            Доделување на работна задача на запослени може да се смета дека е пронаоѓање на совпаѓање
                            во граф, каде <strong>совпаѓањето</strong> `M` во едноставен граф `G = (V, E)` е
                            подмножество од множеството `E` на ребра на графот така да две ребра не се поврзани со ист
                            јазол. Со други зборови совпаѓањето е подмножесто од ребрата така да ако `{s, t}` и `{u, v}`
                            се различни ребра на совпаѓањето тогаш `s`, `t`, `u`, и `v` се различни. За јазелот кој е
                            крајна точка на реброто на совпаѓањето `M` вилеми дека е <strong>совпаѓање</strong> во `M`,
                            во другиот случај вели дека не е совпаѓање. Максимално совпаѓање е совпаѓање со најголем
                            број на јазли. За совпаѓањето `M` во двореднот граф `G = (V, E)` со бипартиции `(V_1, V_2)`
                            велиме дека е комплетно совпаѓање од `V1` во `V2` ако секој јазол во `V_1` e крајна точка на
                            ребро во совпаѓање односно ако `abs(M_1) = abs(V_1)`. На пример, за да се доделат работни
                            задачи така да на запослен му се доделат најголем број на работни задачи потребно е да се
                            најде максималното совпаѓање во графот кој е модел на способностите на запослените. За да се
                            додели запослен на сите работни задачи бараме комплетно совпаѓање од множеството на работни
                            задачи во множеството на запослени. Во примерот 14 ќе го најдеме комплетното совпаѓање од
                            множеството на работни задачи во множеството на запослени за проектот 1, и ова совпаѓање е
                            максимално совпаѓање и ќе покажеме дека не постои комплетно совпаѓање од множеството на
                            работни задачи во множеството на запослени за проектот 2.T
                        </p>

                        <p class='text-danger'>
                            Следи пример како совпаѓањето може да се употреби за да се изградои модел на бракови.
                        </p>

                        <p class='text-danger'>
                            <strong>Пример 15. Бракови на остров: </strong>Бракови на островот Да претпоставиме дека на
                            еден остров има `m` мажи и `n` жени. Секое лице
                            има листа на припадници на спротивниот пол прифатливи како брачен другар. Конструираме
                            бипартитен график `G = (V_1, V_2)` каде што `V_1` е множеството на мажи, а `V_2` е
                            множеството на жени, така да се има ребро ако се прифатливи како брачен другар. Совпаѓањето
                            во овој граф се состои од множество ребра, каде што секој пар од крајни точки на реброто е
                            пар сопруга-сопруга. Максималното совпаѓање е најголем можно множество на брачни парови, а
                            комплетно совпаѓање на `V_1` е множество на брачни парови каде секој маж е оженет но не и
                            сите жени.
                        </p>
                        <hr>

                        <h3 id=''>
                            Нови графови од стар
                        </h3>

                        <p>
                            Понекогаш е потребен само дел од графот за да се реши одреден проблем. На пример, може да е
                            од интерес само делот од голема компјутерска мрежа која ги вклучува компјутерските центри во
                            New York, Denver, Detroit, и Atlanta. Тогаш може да се игнорираат другите компјутерски
                            центри и сите телефонски линии кои не поврзуваат два од ови четри центра. Во графот за
                            големата мрежа можеме да ги отстраниме јазлите кои ги претставуваат сите други центри и да
                            ги одстраниме сите ребра врзани со јазлите кои се отстранети. Н овој начин се добива помал
                            граф кој се нарекува подграф од оргиналниот граф.
                        </p>

                        <div id="term_06" class="alert alert-success swatch-purple" role="alert">
                            <h4 class="alert-heading">Дефиниција 7</h4>
                            <p>
                                Подграф од графот `G = (V, E)` е графот `H = (W, F)`, каде `W sube V` и `F sube E`.
                                Подграфот `H` од `G` е вистински подграф од `G` ако `H != G`.
                            </p>
                        </div>

                        <p>
                            <strong>Пример 18. </strong> Графот `G` прикажан на сликата 15 е подграф од графот `K_5`. If we add the edge connecting c and e to
                            G, we obtain the subgraph induced by W = {a, b, c, e}.
                        </p>

                        <img src='images/graph_25.PNG' class='img-fluid' alt='graph_25'>


                        <p class="text-center">
                            ---------- EOP ----------
                        </p>
                    </div>
                </div>
            </main>
        </div>
    </div>

    <!-- Optional JavaScript -->
    <!-- jQuery first, then Popper.js, then Bootstrap JS -->
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js"
        integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous">
        </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js"
        integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous">
        </script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js"
        integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous">
        </script>
</body>

</html>